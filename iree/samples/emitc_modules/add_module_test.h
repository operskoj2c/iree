// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "iree/vm/api.h"

// This would be generated together with the functions in the header
#include "iree/samples/emitc_modules/add_module.module"

struct add_module_s;
struct add_module_state_s;
typedef struct add_module_s add_module_t;
typedef struct add_module_state_s add_module_state_t;

typedef iree_status_t (*call_i32_i32_t)(iree_vm_stack_t* stack,
                                        void* module_ptr, void* module_state,
                                        int32_t arg0, int32_t* out_ret0);

static iree_status_t call_shim_i32_i32(iree_vm_stack_t* stack,
                                       const iree_vm_function_call_t* call,
                                       call_i32_i32_t target_fn, void* module,
                                       void* module_state,
                                       iree_vm_execution_result_t* out_result) {
  // We can use structs to allow compiler-controlled indexing optimizations,
  // though this won't work for variadic cases.
  // TODO(benvanik): packed attributes.
  typedef struct {
    int32_t arg0;
  } args_t;
  typedef struct {
    int32_t ret0;
  } results_t;

  const args_t* args = (const args_t*)call->arguments.data;
  results_t* results = (results_t*)call->results.data;

  // For simple cases like this (zero or 1 result) we can tail-call.
  return target_fn(stack, module, module_state, args->arg0, &results->ret0);
}

typedef iree_status_t (*call_i32_i32_i32_t)(iree_vm_stack_t* stack,
                                            void* module_ptr,
                                            void* module_state, int32_t arg0,
                                            int32_t arg1, int32_t* out_ret0);

static iree_status_t call_shim_i32_i32_i32(
    iree_vm_stack_t* stack, const iree_vm_function_call_t* call,
    call_i32_i32_i32_t target_fn, void* module, void* module_state,
    iree_vm_execution_result_t* out_result) {
  // We can use structs to allow compiler-controlled indexing optimizations,
  // though this won't work for variadic cases.
  // TODO(benvanik): packed attributes.
  typedef struct {
    int32_t arg0;
    int32_t arg1;
  } args_t;
  typedef struct {
    int32_t ret0;
  } results_t;

  const args_t* args = (const args_t*)call->arguments.data;
  results_t* results = (results_t*)call->results.data;

  // For simple cases like this (zero or 1 result) we can tail-call.
  return target_fn(stack, module, module_state, args->arg0, args->arg1,
                   &results->ret0);
}

static iree_status_t add_module_add(iree_vm_stack_t* stack,
                                    add_module_t* module,
                                    add_module_state_t* module_state,
                                    int32_t arg0, int32_t arg1,
                                    int32_t* out_ret0) {
  //*out_ret0 = arg0 + arg1;
  add_module_add_impl(arg0, arg1, out_ret0);
  return iree_ok_status();
}

static iree_status_t add_module_add_call(iree_vm_stack_t* stack,
                                         add_module_t* module,
                                         add_module_state_t* module_state,
                                         int32_t arg0, int32_t* out_ret0) {
  add_module_add_call_impl(arg0, out_ret0);
  return iree_ok_status();
}

// TODO(marbre/simon-camp): Remove, this should be autogenerated.
static const iree_vm_native_export_descriptor_t add_module_exports_[] = {
    {iree_make_cstring_view("add"), iree_make_cstring_view("0ii.i"), 0, NULL},
    {iree_make_cstring_view("add_call"), iree_make_cstring_view("0i.i"), 0,
     NULL},
};

static const iree_vm_native_function_ptr_t add_module_funcs_[] = {
    {(iree_vm_native_function_shim_t)call_shim_i32_i32_i32,
     (iree_vm_native_function_target_t)add_module_add},
    {(iree_vm_native_function_shim_t)call_shim_i32_i32,
     (iree_vm_native_function_target_t)add_module_add_call},
};
static_assert(IREE_ARRAYSIZE(add_module_funcs_) ==
                  IREE_ARRAYSIZE(add_module_exports_),
              "function pointer table must be 1:1 with exports");

// TODO(marbre/simon-camp): Remove. This is (already) autogenerated.
static const iree_vm_native_module_descriptor_t add_module_descriptor_ = {
    iree_make_cstring_view("add_module"),
    IREE_ARRAYSIZE(add_module_imports_),
    add_module_imports_,
    IREE_ARRAYSIZE(add_module_exports_),
    add_module_exports_,
    IREE_ARRAYSIZE(add_module_funcs_),
    add_module_funcs_,
    0,
    NULL,
};

static iree_status_t add_module_create(iree_allocator_t allocator,
                                       iree_vm_module_t** out_module) {
  // NOTE: this module has neither shared or per-context module state.
  iree_vm_module_t interface;
  IREE_RETURN_IF_ERROR(iree_vm_module_initialize(&interface, NULL));
  return iree_vm_native_module_create(&interface, &add_module_descriptor_,
                                      allocator, out_module);
}
